<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Estimators · Microeconometrics.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>Microeconometrics.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="index.html">Introduction</a></li><li><a class="toctext" href="getting_started.html">Getting started</a></li><li><a class="toctext" href="model_specification.html">Model specification</a></li><li><a class="toctext" href="correlation_structures.html">Correlation structures</a></li><li class="current"><a class="toctext" href="estimators.html">Estimators</a><ul class="internal"><li><a class="toctext" href="#Linear-regression-1">Linear regression</a></li><li><a class="toctext" href="#Binary-choice-1">Binary choice</a></li><li><a class="toctext" href="#Count-data-1">Count data</a></li><li><a class="toctext" href="#Reweighting-methods-1">Reweighting methods</a></li></ul></li><li><a class="toctext" href="methods.html">Methods</a></li><li><a class="toctext" href="hypothesis_tests.html">Hypothesis tests</a></li><li><a class="toctext" href="estimation_tables.html">Estimation tables</a></li><li><a class="toctext" href="bootstrapping.html">Bootstrapping</a></li><li><a class="toctext" href="contributing.html">Contributing</a></li><li><a class="toctext" href="to_do.html">To do</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href="estimators.html">Estimators</a></li></ul><a class="edit-page" href="https://github.com/lbittarello/Microeconometrics.jl/blob/master/docs/src/estimators.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Estimators</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Estimators-1" href="#Estimators-1">Estimators</a></h1><p>The function <code>fit</code> estimates models. It returns a model structure, which contains the estimation sample, the coefficients and their covariance matrix. For example, the output of <code>fit(OLS, MD)</code> has type <code>OLS</code>. Some have additional fields: e.g., two-stage models carry estimates from the first stage and GMM models carry the inverse of the weight matrix.</p><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>If you only need coefficients, pass <code>novar = true</code> to <code>fit</code>.</p></div></div><p>Model structures are subtypes of broader abstract types, such as <code>MLE</code> or <code>GMM</code>, which are ultimately instances of <a href="http://juliastats.github.io/StatsBase.jl/stable/statmodels.html"><code>RegressionModel</code></a>. The type hierarchy is:</p><pre><code class="language-none">RegressionModel
    ParModel
        GMM
        MLE
    TwoStageModel</code></pre><h2><a class="nav-anchor" id="Linear-regression-1" href="#Linear-regression-1">Linear regression</a></h2><h3><a class="nav-anchor" id="Ordinary-least-squares-1" href="#Ordinary-least-squares-1">Ordinary least squares</a></h3><pre><code class="language-julia">fit(OLS, MD::Microdata)</code></pre><p>The <code>Microdata</code> must contain: <code>response</code> and <code>control</code>. See the documentation for linear IV if <code>Microdata</code> includes a treatment. <code>OLS</code> is a subtype of <code>MLE</code>.</p><h3><a class="nav-anchor" id="Linear-IV-1" href="#Linear-IV-1">Linear IV</a></h3><pre><code class="language-julia">fit(IV, MD::Microdata; method::String = &quot;TSLS&quot;)</code></pre><p>The following methods are currently implemented:</p><ul><li><code>method = &quot;TSLS&quot;</code>: two-stage least squares;</li><li><code>method = &quot;Two-step GMM&quot;</code>: optimally weighted two-stage GMM with robust covariance matrix;</li><li><code>method = &quot;Optimal GMM&quot;</code>: optimally weighted two-stage GMM with simplified covariance matrix.</li></ul><p>Additional methods are available for convenience:</p><ul><li><code>method = &quot;OLS&quot;</code>: linear regression of the outcome on the treatment and controls;</li><li><code>method = &quot;First stage&quot;</code>: linear regression of the treatment on the instruments and controls;</li><li><code>method = &quot;Reduced form&quot;</code>: linear regression of the outcome on the instruments and controls.</li></ul><p>The <code>Microdata</code> must contain: <code>response</code>, <code>treatment</code>, <code>control</code> and <code>instrument</code>. <code>IV</code> is a subtype of <code>GMM</code>.</p><h2><a class="nav-anchor" id="Binary-choice-1" href="#Binary-choice-1">Binary choice</a></h2><pre><code class="language-julia">fit(Logit, MD::Microdata)
fit(Probit, MD::Microdata)
fit(Cloglog, MD::Microdata)</code></pre><p>The <code>Microdata</code> must contain: <code>response</code> and <code>control</code>. The outcome should be binary. The model structures are subtypes of <code>MLE</code>.</p><h2><a class="nav-anchor" id="Count-data-1" href="#Count-data-1">Count data</a></h2><pre><code class="language-julia">fit(Poisson, MD::Microdata; novar::Bool = false)</code></pre><p>The <code>Microdata</code> must contain: <code>response</code> and <code>control</code>. The <code>Microdata</code> may contain an <code>offset</code>. See the documentation for linear IV if <code>Microdata</code> includes a treatment. The outcome must be weakly positive. <code>Poisson</code> is a subtype of <code>MLE</code>.</p><pre><code class="language-julia">fit(IVPoisson, MD::Microdata; novar::Bool = false, method::String = &quot;One-step GMM&quot;)
fit(Mullahy, MD::Microdata; novar::Bool = false, method::String = &quot;One-step GMM&quot;)</code></pre><p><code>IVPoisson</code> fits the exponential conditional mean model with additive errors. <code>Mullahy</code> fits the exponential conditional mean model with multiplicative errors (<a href="http://www.jstor.org/stable/2951410">Mullahy, 1997</a>).</p><p>The following methods are currently implemented:</p><ul><li><code>method = &quot;One-step GMM&quot;</code>: unweighted one-stage GMM;</li><li><code>method = &quot;TSLS&quot;</code>: one-stage GMM with the average outer product of the instrument vector as weight matrix;</li><li><code>method = &quot;Two-step GMM&quot;</code>: optimally weighted two-stage GMM with robust covariance matrix;</li><li><code>method = &quot;Optimal GMM&quot;</code>: optimally weighted two-stage GMM with simplified covariance matrix.</li></ul><p>The models are estimated with the Gauss–Newton algorithm. The first stage of the two-stage specifications is estimated with the average outer product of the instrument vector as weight matrix.</p><p>Additional methods are available for convenience:</p><ul><li><code>method = &quot;Poisson&quot;</code>: Poisson regression of the outcome on the treatment and controls;</li><li><code>method = &quot;Reduced form&quot;</code>: Poisson regression of the outcome on the instruments and controls.</li></ul><p>The <code>Microdata</code> must contain: <code>response</code>, <code>treatment</code>, <code>control</code> and <code>instrument</code>. The <code>Microdata</code> may contain an <code>offset</code>. The outcome must be weakly positive. <code>IVPoisson</code> and <code>Mullahy</code> are subtypes of <code>GMM</code>.</p><h2><a class="nav-anchor" id="Reweighting-methods-1" href="#Reweighting-methods-1">Reweighting methods</a></h2><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>All reweighting models require the specification of a first stage. They come in two flavors. In the first, you specify the first-stage model. In the second, you pass a previously fitted model. The latter is more verbose, but it allows you to customize and reuse the first stage.</p></div></div><pre><code class="language-julia">fit(IPW, M₁::Type{Micromodel}, MD::Microdata; trim::AbstractFloat = 0.0)
fit(IPW, M₁::Micromodel, MD::Microdata; trim::AbstractFloat = 0.0)</code></pre><p><code>IPW</code> estimates average treatment effects by inverse probability weighting. In a first stage, we use model <code>M₁</code> to forecast the conditional probability of treatment take-up and construct estimation weights. In the second stage, we regress the outcome on the treatment and an intercept by weighted least squares. The intercept gives the mean outcome of the untreated. We ignore observations whose score is below <code>trim</code> or above <code>1 - trim</code> (see <a href="http://jstor.org/stable/27798811">Crump et al. (2009)</a>).</p><p>The <code>Microdata</code> must contain: <code>response</code>, <code>treatment</code> and <code>control</code>. The treatment must be binary. <code>IPW</code> is a subtype of <code>TwoStageModel</code>.</p><pre><code class="language-julia">fit(Abadie, M₂::Type{ParModel}, M₁::Type{Micromodel}, MD::Microdata; trim::AbstractFloat = 0.0, kwargs...)
fit(Abadie, M₂::Type{ParModel}, M₁::Micromodel, MD::Microdata; trim::AbstractFloat = 0.0 kwargs...)</code></pre><p><code>Abadie</code> estimates local average response functions according to <a href="https://www.sciencedirect.com/science/article/pii/S0304407602002014">Abadie (2003)</a>. In a first stage, we use model <code>M₁</code> to forecast the conditional probability of instrument take-up and construct estimation weights. In the second stage, we fit <code>M₂</code> with the weights from the first stage. Keywords customize the second-stage estimator. We ignore observations whose score is below <code>trim</code> or above <code>1 - trim</code> (see <a href="http://jstor.org/stable/27798811">Crump et al. (2009)</a>).</p><p>The <code>Microdata</code> must contain: <code>response</code>, <code>treatment</code>, <code>control</code> and <code>instrument</code>. The treatment and the instrument must be binary. <code>Abadie</code> is a subtype of <code>TwoStageModel</code>.</p><pre><code class="language-julia">fit(FrölichMelly, M₁::Type{Micromodel}, MD::Microdata; trim::AbstractFloat = 0.0)
fit(FrölichMelly, M₁::Micromodel, MD::Microdata; trim::AbstractFloat = 0.0)</code></pre><p>This model estimates unconditional local average effects according to <a href="http://doi.org/10.1080/07350015.2013.803869">Frölich and Melly (2013)</a>. In a first stage, we use model <code>M₁</code> to forecast the conditional probability of instrument take-up and construct estimation weights. In the second stage, we regress the outcome on the treatment and an intercept by weighted least squares. The intercept gives mean outcome of untreated compliers. We ignore observations whose score is below <code>trim</code> or above <code>1 - trim</code> (see <a href="http://jstor.org/stable/27798811">Crump et al. (2009)</a>).</p><p>The <code>Microdata</code> must contain: <code>response</code>, <code>treatment</code>, <code>control</code> and <code>instrument</code>. The treatment and the instrument must be binary. <code>FrölichMelly</code> is a subtype of <code>TwoStageModel</code>.</p><pre><code class="language-julia">fit(Tan, M₁::Type{Micromodel}, MD::Microdata; trim::AbstractFloat = 0.0)
fit(Tan, M₁::Micromodel, MD::Microdata; trim::AbstractFloat = 0.0)</code></pre><p>This model estimates the unconditional local average treatment effects according to <a href="http://doi.org/10.1198/016214505000001366">Tan (2006)</a>. In a first stage, we use model <code>M₁</code> to forecast the conditional probability of instrument take-up and construct estimation weights. In the second stage, we regress the outcome on the treatment and an intercept by weighted two-stage least squares. The intercept gives mean outcome of untreated compliers. We ignore observations whose score is below <code>trim</code> or above <code>1 - trim</code> (see <a href="http://jstor.org/stable/27798811">Crump et al. (2009)</a>).</p><p>The <code>Microdata</code> must contain: <code>response</code>, <code>treatment</code>, <code>control</code> and <code>instrument</code>. The treatment and the instrument must be binary. <code>Tan</code> is a subtype of <code>TwoStageModel</code>.</p><footer><hr/><a class="previous" href="correlation_structures.html"><span class="direction">Previous</span><span class="title">Correlation structures</span></a><a class="next" href="methods.html"><span class="direction">Next</span><span class="title">Methods</span></a></footer></article></body></html>
