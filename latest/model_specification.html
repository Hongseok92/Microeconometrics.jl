<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Model specification · Microeconometrics.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>Microeconometrics.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="index.html">Introduction</a></li><li><a class="toctext" href="getting_started.html">Getting started</a></li><li class="current"><a class="toctext" href="model_specification.html">Model specification</a><ul class="internal"><li><a class="toctext" href="#CorrStructure-1"><code>CorrStructure</code></a></li><li><a class="toctext" href="#Microdata-1"><code>Microdata</code></a></li></ul></li><li><a class="toctext" href="estimators.html">Estimators</a></li><li><a class="toctext" href="methods.html">Methods</a></li><li><a class="toctext" href="contributing.html">Contributing</a></li><li><a class="toctext" href="to_do.html">To do</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href="model_specification.html">Model specification</a></li></ul><a class="edit-page" href="https://github.com/lbittarello/Microeconometrics.jl/blob/master/docs/src/model_specification.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Model specification</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Model-specification-1" href="#Model-specification-1">Model specification</a></h1><p>Before fitting the model, one must specify the correlation pattern of the error term (a <code>CorrStructure</code>) and the components of the model (a <code>Microdata</code>).</p><h2><a class="nav-anchor" id="CorrStructure-1" href="#CorrStructure-1"><code>CorrStructure</code></a></h2><p>This structure specifies the correlation between observations. It determines the calculation of standard errors.</p><p>All constructors accept the Boolean keyword <code>adj</code>, which defaults to <code>true</code>. If <code>true</code>, a finite-sample adjustment is applied to the variance matrix. The adjustment factor is  / (n - 1), where n is the number of clusters for clustered data and the number of observations otherwise.</p><p>Four subtypes are currently available:</p><h3><a class="nav-anchor" id="Homoscedastic-1" href="#Homoscedastic-1">Homoscedastic</a></h3><pre><code class="language-julia">Homoscedastic(method::String = &quot;OIM&quot;; adj::Bool = true)</code></pre><p>Observations are independent and identically distributed. The optional <code>method</code> argument controls the estimation of the variance matrix: <code>&quot;OIM&quot;</code> uses the observed information matrix, whereas <code>&quot;OPG&quot;</code> uses the outer product of the gradient. (They are equivalent for OLS.) Only OLS and maximum-likelihood estimators support homoscedastic errors.</p><h3><a class="nav-anchor" id="Heteroscedastic-1" href="#Heteroscedastic-1">Heteroscedastic</a></h3><pre><code class="language-julia">Heteroscedastic(; adj::Bool = true)</code></pre><p>Observations are independent, but they may differ in distribution. This structure leads to sandwich covariance matrices (a.k.a. Huber-Eicker-White).</p><h3><a class="nav-anchor" id="Clustered-1" href="#Clustered-1">Clustered</a></h3><pre><code class="language-julia">Clustered(DF::Microdata, cluster::Symbol; adj::Bool = true)</code></pre><p>Observations are independent across clusters, but their joint distribution within clusters is arbitrary. <code>cluster</code> specifies the column of <code>DF</code> to cluster on.</p><h3><a class="nav-anchor" id="CrossCorrelated-1" href="#CrossCorrelated-1">CrossCorrelated</a></h3><p>This structure accommodates other correlation structures. The first argument determines the precise pattern. The following methods are available:</p><pre><code class="language-julia">CrossCorrelated(&quot;Two-way clustering&quot;, DF::DataFrame, cluster₁::Symbol, cluster₂::Symbol; adj::Bool = true)</code></pre><p>Observations may be arbitrarily correlated if they share any cluster.</p><pre><code class="language-julia">CrossCorrelated(&quot;Time&quot;, DF::DataFrame, time::Symbol, bandwidth::Real; adj::Bool = true)
CrossCorrelated(&quot;Time&quot;, DF::DataFrame, time::Symbol, kernel::function; adj::Bool = true)</code></pre><p>The maximum possible correlation between two observations declines with the time difference between them. Correlation is arbitrary below that limit. The bandwidth and the kernel function control the upper bound. <code>time</code> specifies the column of <code>DF</code> that contains the date of each observation (<code>Date</code>).</p><p>The first method takes a bandwidth and uses the Parzen kernel. The second method takes a kernel function instead, which must incorporate the bandwidth. The first method is equivalent to setting <code>x -&gt; parzen(x / bandwidth)</code>. The following kernels are predefined for convenience: Bartlett (<code>bartlett</code>), Parzen (<code>parzen</code>), Truncated (<code>truncated</code>) and Tukey-Hanning (<code>tukeyhanning</code>). See <a href="http://jstor.org/stable/2938229">Andrews (1991)</a> for formulae.</p><pre><code class="language-julia">CrossCorrelated(&quot;Space&quot;, DF::DataFrame, latitude::Symbol, longitude::Symbol, bandwidth::Real; adj::Bool = true)
CrossCorrelated(&quot;Space&quot;, DF::DataFrame, latitude::Symbol, longitude::Symbol, kernel::function; adj::Bool = true)</code></pre><p>The maximum possible correlation between two observations declines with the spatial distance between them. Correlation is arbitrary below that limit. The bandwidth and the kernel function control the upper bound. <code>latitude</code> and <code>longitude</code> specify the columns of <code>DF</code> that contain the coordinates of each observation (<code>Float64</code>).</p><p>For an explanation of the difference between the two methods, see <code>CrossCorrelated(&quot;time&quot;, args...)</code> above.</p><pre><code class="language-julia">CrossCorrelated(&quot;Time and space&quot;,
    DF::DataFrame,
    time::Symbol,
    bandwidth_time::Real,
    latitude::Symbol,
    longitude::Symbol,
    bandwidth_space::Real;
    adj::Bool = true)
CrossCorrelated(&quot;Time and space&quot;,
    DF::DataFrame,
    time::Symbol,
    kernel_time::Function,
    latitude::Symbol,
    longitude::Symbol,
    kernel_space::Function;
    adj::Bool = true)</code></pre><p>The maximum possible correlation between two observations declines with the time difference and the spatial distance between them. Correlation is arbitrary below that limit. The bandwidths and the kernel functions control the upper bound. <code>time</code> specifies the column of <code>DF</code> that contains the date of each observation. <code>latitude</code> and <code>longitude</code> specify the columns of <code>DF</code> that contain the coordinates of each observation (<code>Float64</code>).</p><p>For an explanation of the difference between the two methods, see <code>CrossCorrelated(&quot;time&quot;, args...)</code> above.</p><h2><a class="nav-anchor" id="Microdata-1" href="#Microdata-1"><code>Microdata</code></a></h2><p>This structure combines the functionalities of <code>Formula</code>, <code>ModelFrame</code> and <code>ModelMatrix</code> from <a href="https://github.com/JuliaStats/StatsModels.jl"><em>StatsModels</em></a>. It contains a <code>Matrix{Float64}</code> (the data matrix), a map from model components to matrix columns, a correlation structure and weights (inter alia).</p><pre><code class="language-julia">Microdata(
    DF::DataFrame;
    vcov::CorrStructure = Heteroscedastic(),
    weights::AbstractWeights = UnitWeights(size(DF, 1)),
    subset::AbstractVector{Bool} = trues(size(DF, 1)),
    kwargs...)</code></pre><p><code>subset</code> determines the estimation sample. Set a row to <code>true</code> if the corresponding row of <code>DF</code> should be included and <code>false</code> if it should be excluded. This keyword is useful in two situations. First, you have precomputed <code>vcov</code> based on the entire sample. <code>Microdata</code> will copy the correlation structure and restrict it to relevant observations. Second, you are comparing subgroup effects and observations in different subgroups may correlate (e.g., they may belong to the same cluster). <code>hausman_2s</code> will account for that correlation if the <code>Microdata</code>s were constructed with <code>subset</code>.</p><p><code>weights</code> is a <a href="http://juliastats.github.io/StatsBase.jl/stable/weights.html">weight vector</a>. Except for frequency weights, the weight vector is normalized to sum up to the number of observations in the sample.</p><p>Additional keywords determine the model components. All regression models need a <code>response</code>, but other requirements may vary. For example, <code>OLS</code> asks for <code>response</code> and <code>control</code>. See the <a href="#getting-started">introduction</a> for examples. Conventional sets include:</p><ul><li><p><code>response</code>: the response, outcome or dependent variable;</p></li><li><p><code>control</code>: exogenous explanatory variables (n.b.: you must explicitly include intercepts);</p></li><li><p><code>treatment</code>: endogenous explanatory variables;</p></li><li><p><code>instrument</code>: instrumental variables (i.e., excluded exogenous variables).</p></li></ul><p>You pass these sets as strings, following <a href="http://juliastats.github.io/StatsModels.jl/latest/formula.html">syntax of <code>Formula</code></a>.</p><pre><code class="language-julia">Microdata(MD::Microdata; kwargs...)</code></pre><p>It is also possible to base new <code>Microdata</code> on existing <code>Microdata</code>. This constructor allows you to reassign variables to new sets. You can create new variable sets. If you do not redefine a set, it is preserved. To suppress a set, redefine it to <code>&quot;&quot;</code>. You cannot add new variables, modify the correlation structure, restrict the sample or reweight observations.</p><p>This functionality is useful if you wish to compare specifications. Rather than building separate data matrices for each one of them, you can build a master <code>Microdata</code>, holding all variables of interest, and adjust its map as you go through specifications.</p><footer><hr/><a class="previous" href="getting_started.html"><span class="direction">Previous</span><span class="title">Getting started</span></a><a class="next" href="estimators.html"><span class="direction">Next</span><span class="title">Estimators</span></a></footer></article></body></html>
