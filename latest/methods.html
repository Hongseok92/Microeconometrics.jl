<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Methods · Microeconometrics.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>Microeconometrics.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="index.html">Introduction</a></li><li><a class="toctext" href="getting_started.html">Getting started</a></li><li><a class="toctext" href="model_specification.html">Model specification</a></li><li><a class="toctext" href="estimators.html">Estimators</a></li><li class="current"><a class="toctext" href="methods.html">Methods</a><ul class="internal"><li><a class="toctext" href="#Methods-from-*StatsBase.jl*-1">Methods from <em>StatsBase.jl</em></a></li><li><a class="toctext" href="#Additional-methods-1">Additional methods</a></li><li><a class="toctext" href="#Hausman-test-1">Hausman test</a></li></ul></li><li><a class="toctext" href="contributing.html">Contributing</a></li><li><a class="toctext" href="to_do.html">To do</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href="methods.html">Methods</a></li></ul><a class="edit-page" href="https://github.com/lbittarello/Microeconometrics.jl/blob/master/docs/src/methods.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Methods</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Methods-1" href="#Methods-1">Methods</a></h1><h2><a class="nav-anchor" id="Methods-from-*StatsBase.jl*-1" href="#Methods-from-*StatsBase.jl*-1">Methods from <em>StatsBase.jl</em></a></h2><p>This package supports the methods for regression models of <a href="http://juliastats.github.io/StatsBase.jl/stable/statmodels.html"><em>StatsBase.jl</em></a>.</p><p>The following functions are available for all models: <code>nobs</code> and <code>model_response</code>.</p><p>The following functions are available for parametric models: <code>dof</code>, <code>dof_residual</code>, <code>coef</code>, <code>stderr</code>, <code>vcov</code>, <code>confint</code>, <code>coefnames</code> and <code>coeftable</code>. Two keywords customize the behavior of <code>coeftable</code>: <code>digits</code> (integer: controls rounding) and <code>level</code> (float: controls the level of the confidence interval – 0.0 for none). Note that all methods refer to the second stage of two-stage models.</p><p>The following functions are available for maximum-likelihood estimators: <code>aic</code>, <code>aicc</code>, <code>bic</code>, <code>deviance</code>, <code>nulldeviance</code>, <code>loglikelihood</code>, <code>nullloglikelihood</code>, <code>r2</code> and <code>adjr2</code>. There are also R² methods for OLS and IV.</p><p>Most models support <code>predict</code> and <code>fitted</code>. <code>predict</code> estimates the index of single-index models. <code>fitted</code> computes the conditional outcome expectation. For example, <code>predict</code> estimates the Xβ of a logit model and <code>fitted</code> computes logistic(Xβ). Support for <code>residuals</code> depends on the availability of <code>fitted</code>. Out-of-sample forecast is supported.</p><h2><a class="nav-anchor" id="Additional-methods-1" href="#Additional-methods-1">Additional methods</a></h2><ul><li><p><code>tstat</code>: the <em>t</em>-statistic (i.e., the ratio of coefficients to standard error);</p></li><li><p><code>pval</code>: the <em>p</em>-value of a two-sided significance test;</p></li><li><p><code>first_stage</code>: the first-stage estimates of a two-stage model.</p></li></ul><h2><a class="nav-anchor" id="Hausman-test-1" href="#Hausman-test-1">Hausman test</a></h2><p>These functions compute the difference in coefficients between two parametric models. They return a <code>ParObject</code>, which contains the vector of differences, their covariance matrix and labels. Our implementation is based on the GMM representation of the joint estimation problem (see Subsection 8.3.2 of Cameron and Trivedi (2005)). The optional argument <code>names</code> specifies the coefficients of interest as they appear on regression tables (be careful with categorical variables!). </p><pre><code class="language-julia">hausman_1s(
        model₁::Union{GMM, ParModel, TwoStageModel},
        model₂::Union{GMM, ParModel, TwoStageModel},
        names::Vector{String} = intersect(coefnames(obj₁), coefnames(obj₂))
    )</code></pre><p>This function is appropriate when <code>model₁</code> and <code>model₂</code> were both based on the same estimation sample.</p><pre><code class="language-julia">hausman_2s(
        model₁::Union{GMM, ParModel, TwoStageModel},
        model₂::Union{GMM, ParModel, TwoStageModel},
        names::Vector{String} = intersect(coefnames(obj₁), coefnames(obj₂))
    )</code></pre><p>This function is appropriate when <code>model₁</code> and <code>model₂</code> were based on independent samples. For example, the samples might consist of independent observations with no overlap.</p><pre><code class="language-julia">hausman_2s(
        model₁::Union{GMM, ParModel, TwoStageModel},
        model₂::Union{GMM, ParModel, TwoStageModel},
        corr::CorrStructure,
        names::Vector{String} = intersect(coefnames(obj₁), coefnames(obj₂))
    )</code></pre><p>This function is appropriate when <code>model₁</code> and <code>model₂</code> were based on dependent samples. For example, the samples might consist of independent observations with some overlap or clustered observations with shared clusters. The correlation structure <code>corr</code> must specify the correlation between all observations of both estimation samples. For example, you could construct <code>corr</code> for the entire dataset and construct the samples via the <code>subset</code> keyword to <code>Microdata</code>.</p><footer><hr/><a class="previous" href="estimators.html"><span class="direction">Previous</span><span class="title">Estimators</span></a><a class="next" href="contributing.html"><span class="direction">Next</span><span class="title">Contributing</span></a></footer></article></body></html>
